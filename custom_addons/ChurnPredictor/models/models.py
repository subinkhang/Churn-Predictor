# -*- coding: utf-8 -*-
import base64
import json # <<< TH√äM M·ªöI
import requests # <<< TH√äM M·ªöI
import logging # <<< TH√äM M·ªöI
import markdown2 # <<< TH√äM M·ªöI

from odoo import models, fields, api, _ # <<< TH√äM _
from odoo.exceptions import UserError # <<< TH√äM M·ªöI
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

_logger = logging.getLogger(__name__)

class ChurnPrediction(models.Model):
    """
    Model n√†y d√πng ƒë·ªÉ l∆∞u tr·ªØ k·∫øt qu·∫£ c·ªßa m·ªói l·∫ßn d·ª± ƒëo√°n churn.
    M·ªói b·∫£n ghi (record) trong model n√†y t∆∞∆°ng ·ª©ng v·ªõi m·ªôt l·∫ßn ch·∫°y d·ª± ƒëo√°n
    cho m·ªôt kh√°ch h√†ng t·∫°i m·ªôt th·ªùi ƒëi·ªÉm c·ª• th·ªÉ.
    """
    _name = 'churn.prediction'
    _description = 'Customer Churn Prediction Result'
    _order = 'prediction_date desc' # S·∫Øp x·∫øp m·∫∑c ƒë·ªãnh theo ng√†y d·ª± ƒëo√°n m·ªõi nh·∫•t

    # --- C√°c tr∆∞·ªùng (Fields) ch√≠nh c·ªßa Model ---

    # M·ªëi quan h·ªá Many2one: M·ªói k·∫øt qu·∫£ d·ª± ƒëo√°n thu·ªôc v·ªÅ M·ªòT kh√°ch h√†ng.
    # 'res.partner' l√† model m·∫∑c ƒë·ªãnh c·ªßa Odoo ƒë·ªÉ qu·∫£n l√Ω li√™n h·ªá (kh√°ch h√†ng, nh√† cung c·∫•p...).
    customer_id = fields.Many2one(
        'res.partner',
        string='Customer',
        required=True,
        ondelete='cascade', # N·∫øu kh√°ch h√†ng b·ªã x√≥a, k·∫øt qu·∫£ d·ª± ƒëo√°n li√™n quan c≈©ng b·ªã x√≥a.
        help="The customer for whom the prediction was made."
    )

    # Ng√†y v√† gi·ªù th·ª±c hi·ªán d·ª± ƒëo√°n. M·∫∑c ƒë·ªãnh l√† th·ªùi ƒëi·ªÉm t·∫°o b·∫£n ghi.
    prediction_date = fields.Datetime(
        string='Prediction Date',
        required=True,
        default=fields.Datetime.now,
        readonly=True,
        help="Date and time when the prediction was generated."
    )

    # K·∫øt qu·∫£ d·ª± ƒëo√°n (d·∫°ng l·ª±a ch·ªçn).
    prediction_result = fields.Selection(
        [
            ('churn', 'Churn'),
            ('no_churn', 'No Churn')
        ],
        string='Prediction Result',
        required=False,
        help="The outcome predicted by the model (Churn or No Churn)."
    )

    # X√°c su·∫•t kh√°ch h√†ng s·∫Ω r·ªùi b·ªè (t·ª´ 0.0 ƒë·∫øn 100.0).
    probability = fields.Float(
        string='Churn Probability (%)',
        digits=(16, 2), # Hi·ªÉn th·ªã v·ªõi 2 ch·ªØ s·ªë th·∫≠p ph√¢n.
        help="The probability (from 0 to 100) that the customer will churn, as calculated by the model."
    )

    # Tr∆∞·ªùng HTML ƒë·ªÉ l∆∞u v√† hi·ªÉn th·ªã bi·ªÉu ƒë·ªì gi·∫£i th√≠ch t·ª´ SHAP.
    # Ch√∫ng ta s·∫Ω l∆∞u tr·ª±c ti·∫øp m√£ HTML c·ªßa bi·ªÉu ƒë·ªì v√†o ƒë√¢y.
    shap_html = fields.Binary(
        string='Prediction Explanation (SHAP Data)',
        readonly=True
    )
    # Tr∆∞·ªùng Text ƒë·ªÉ l∆∞u d·ªØ li·ªáu SHAP th√¥ d·∫°ng JSON.
    # D·ªØ li·ªáu n√†y s·∫Ω ƒë∆∞·ª£c g·ª≠i t·ªõi AI ƒë·ªÉ di·ªÖn gi·∫£i.
    shap_data_json = fields.Text(
        string='SHAP Raw Data (JSON)',
        readonly=True,
        help="Raw SHAP data (base value, feature values, SHAP values) stored in JSON format, used for generating AI explanations."
    )

    shap_ai_explanation = fields.Text(
        string='AI-Powered Explanation',
        readonly=True,
        help="The natural language explanation of the prediction, generated by an AI service."
    )

    # Th√™m m·ªôt tr∆∞·ªùng ƒë·ªÉ hi·ªÉn th·ªã t√™n kh√°ch h√†ng cho ti·ªán l·ª£i
    # related='customer_id.name' s·∫Ω t·ª± ƒë·ªông l·∫•y gi√° tr·ªã t·ª´ tr∆∞·ªùng 'name' c·ªßa model 'res.partner'
    customer_name = fields.Char(
        string="Customer Name",
        related='customer_id.name',
        readonly=True,
        store=True # L∆∞u v√†o DB ƒë·ªÉ c√≥ th·ªÉ t√¨m ki·∫øm/nh√≥m theo t√™n
    )
    
    churn_rate = fields.Float(
        string="Churn Rate",
        compute='_compute_churn_rate',
        store=True, # store=True l√† b·∫Øt bu·ªôc ƒë·ªÉ c√≥ th·ªÉ group by v√† t√≠nh to√°n tr√™n view
        group_operator='avg', # Ch·ªâ ƒë·ªãnh c√°ch Odoo t·ªïng h·ª£p tr∆∞·ªùng n√†y
    )    
    
    customer_state_id = fields.Many2one(
        'res.country.state', 
        string='Customer State',
        related='customer_id.state_id',
        store=True, # B·∫Øt bu·ªôc ph·∫£i c√≥ store=True ƒë·ªÉ c√≥ th·ªÉ group_by
        readonly=True,
    )
    
    probability_level = fields.Selection(
        [
            ('low', 'Low Risk (0-30%)'),
            ('medium', 'Medium Risk (30-70%)'),
            ('high', 'High Risk (70-100%)')
        ],
        string="Probability Level",
        compute='_compute_probability_level',
        store=True, # B·∫Øt bu·ªôc ph·∫£i c√≥ store=True ƒë·ªÉ c√≥ th·ªÉ group_by
    )
    
    is_high_risk = fields.Integer(
        string="Is High Risk",
        compute='_compute_is_high_risk',
        store=True, # B·∫Øt bu·ªôc ƒë·ªÉ c√≥ th·ªÉ t√≠nh to√°n tr√™n view
        default=0,
    )
    
    product_count = fields.Integer(
        string="Number of Products Purchased",
        default=1, # Ho·∫∑c m·ªôt gi√° tr·ªã m·∫∑c ƒë·ªãnh h·ª£p l√Ω
        help="The number of distinct products the customer has purchased."
    )
    
    x_feat_segment = fields.Integer(
        string="Customer Segment",
        related='customer_id.x_feat_segment',
        store=True, # B·∫ÆT BU·ªòC ƒë·ªÉ c√≥ th·ªÉ group_by
        readonly=True
    )

    # L·∫•y tr∆∞·ªùng "Last Product Category" t·ª´ kh√°ch h√†ng li√™n quan
    x_feat_product_category_name_english_last = fields.Char(
        string="Last Product Category",
        related='customer_id.x_feat_product_category_name_english_last',
        store=True, # B·∫ÆT BU·ªòC ƒë·ªÉ c√≥ th·ªÉ group_by
        readonly=True
    )

    # L·∫•y tr∆∞·ªùng "Category Avg Gap" t·ª´ kh√°ch h√†ng li√™n quan
    x_feat_category_avg_gap = fields.Float(
        string="Category Avg Gap (Days)",
        related='customer_id.x_feat_category_avg_gap',
        store=True, # B·∫ÆT BU·ªòC ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng l√†m measure
        readonly=True,
        group_operator='avg' # Ch·ªâ ƒë·ªãnh ph√©p t√≠nh m·∫∑c ƒë·ªãnh l√† trung b√¨nh
    )

    @api.depends('probability_level')
    def _compute_is_high_risk(self):
        """
        G√°n gi√° tr·ªã 1 n·∫øu l√† 'high', ng∆∞·ª£c l·∫°i l√† 0.
        Vi·ªác t√≠nh t·ªïng (sum) c·ªßa tr∆∞·ªùng n√†y s·∫Ω cho ra s·ªë kh√°ch h√†ng nguy c∆° cao.
        """
        for record in self:
            if record.probability_level == 'high':
                record.is_high_risk = 1
            else:
                record.is_high_risk = 0

    @api.depends('probability')
    def _compute_probability_level(self):
        """
        T·ª± ƒë·ªông ph√¢n lo·∫°i m·ª©c ƒë·ªô r·ªßi ro d·ª±a tr√™n x√°c su·∫•t churn.
        """
        for record in self:
            if record.probability < 30:
                record.probability_level = 'low'
            elif record.probability < 70:
                record.probability_level = 'medium'
            else:
                record.probability_level = 'high'

    @api.depends('prediction_result')
    def _compute_churn_rate(self):
        """
        Tr∆∞·ªùng n√†y tr·∫£ v·ªÅ 100 n·∫øu l√† churn, 0 n·∫øu kh√¥ng.
        Khi t√≠nh trung b√¨nh (avg) tr√™n view, n√≥ s·∫Ω ra ƒë√∫ng t·ª∑ l·ªá %.
        """
        for record in self:
            if record.prediction_result == 'churn':
                record.churn_rate = 100.0
            else:
                record.churn_rate = 0.0
                
    @api.model
    def get_dashboard_kpis(self, domain=None):
        """
        H√†m n√†y ƒë∆∞·ª£c g·ªçi t·ª´ JavaScript ƒë·ªÉ l·∫•y d·ªØ li·ªáu cho c√°c √¥ KPI.
        N√≥ ƒë√£ ƒë∆∞·ª£c n√¢ng c·∫•p ƒë·ªÉ ch·∫•p nh·∫≠n m·ªôt `domain` ƒë·ªÉ l·ªçc d·ªØ li·ªáu.
        """
        # N·∫øu kh√¥ng c√≥ domain ƒë∆∞·ª£c truy·ªÅn v√†o, s·ª≠ d·ª•ng m·ªôt domain tr·ªëng (l·∫•y t·∫•t c·∫£)
        if domain is None:
            domain = []
            
        # ƒê·ªçc d·ªØ li·ªáu t·ª´ c√°c b·∫£n ghi d·ª± ƒëo√°n ƒë√£ ƒë∆∞·ª£c l·ªçc
        predictions = self.search_read(
            domain,
            ['is_high_risk', 'probability', 'churn_rate']
        )
        
        # L·∫•y t·ªïng s·ªë b·∫£n ghi d·ª± ƒëo√°n (tr∆∞·ªõc khi l·ªçc) ƒë·ªÉ t√≠nh t·ª∑ l·ªá %
        total_predictions_overall = self.search_count([])

        total_predictions_in_group = len(predictions)
        high_risk_customers = sum(p['is_high_risk'] for p in predictions)
        
        # T√≠nh to√°n ƒë·ªÉ tr√°nh l·ªói chia cho 0
        average_churn_probability = 0
        overall_churn_rate = 0
        high_risk_percentage = 0

        if total_predictions_in_group > 0:
            average_churn_probability = sum(p['probability'] for p in predictions) / total_predictions_in_group
            overall_churn_rate = sum(p['churn_rate'] for p in predictions) / total_predictions_in_group
        
        if total_predictions_overall > 0:
            # T·ª∑ l·ªá % kh√°ch h√†ng r·ªßi ro cao c·ªßa nh√≥m hi·ªán t·∫°i so v·ªõi T·ªîNG S·ªê
            high_risk_percentage = (high_risk_customers / total_predictions_overall) * 100

        return {
            'total_predictions': total_predictions_in_group,
            'high_risk_customers': high_risk_customers,
            'average_churn_probability': round(average_churn_probability, 2),
            'overall_churn_rate': round(overall_churn_rate, 2),
            'high_risk_percentage': round(high_risk_percentage, 1), # D·ªØ li·ªáu cho progress bar
        }
        
    def action_generate_ai_explanation(self):
        """
        [ƒê√É S·ª¨A] Chuy·ªÉn sang s·ª≠ d·ª•ng API c·ªßa OpenAI (GPT) ƒë·ªÉ t·∫°o gi·∫£i th√≠ch.
        """
        self.ensure_one()
        
        _logger.info(">>> [AI XAI - OpenAI] B·∫Øt ƒë·∫ßu action_generate_ai_explanation cho prediction ID: %d", self.id)

        # --- B∆Ø·ªöC 1: L·∫§Y C·∫§U H√åNH (ƒê√É S·ª¨A) ---
        config_param = self.env['ir.config_parameter'].sudo()
        # <<< THAY ƒê·ªîI: L·∫•y key v√† endpoint c·ªßa OpenAI >>>
        api_key = config_param.get_param('churn_predictor.openai_api_key')
        api_endpoint = config_param.get_param('churn_predictor.openai_api_endpoint')

        if not api_key or not api_endpoint or api_key == 'sk-YourSecretKeyHere':
            raise UserError(_("OpenAI API is not configured. Please set your API key in Technical Settings."))
        
        if not self.shap_data_json:
            raise UserError(_("No SHAP data available."))

        # --- B∆Ø·ªöC 2: CHU·∫®N B·ªä D·ªÆ LI·ªÜU V√Ä PROMPT (Gi·ªØ nguy√™n logic c≈©) ---
        # (To√†n b·ªô logic chu·∫©n b·ªã prompt c·ªßa b·∫°n t·ª´ B∆Ø·ªöC 2 ƒë·∫øn B∆Ø·ªöC 3 v·∫´n gi·ªØ nguy√™n)
        try:
            shap_data = json.loads(self.shap_data_json)
        except json.JSONDecodeError:
            raise UserError(_("Could not read the SHAP data."))

        feature_impacts = sorted(
            zip(shap_data['feature_names'], shap_data['shap_values'], shap_data['feature_values']),
            key=lambda x: abs(x[1]),
            reverse=True
        )
        
        # --- B∆Ø·ªöC 2.1: L·∫§Y D·ªÆ LI·ªÜU B·ªêI C·∫¢NH (CONTEXT DATA) ---
        
        # 1. Product Category
        raw_category = self.customer_id.x_feat_product_category_name_english_last or "Unknown"
        customer_category = raw_category.replace('_', ' ').title()

        # 2. C√°c ch·ªâ s·ªë h√†nh vi & Segment
        personal_gap = self.customer_id.x_feat_personal_avg_gap or 0.0
        category_gap = self.customer_id.x_feat_category_avg_gap or 0.0
        segment_id = self.customer_id.x_feat_segment or 0

        # === [NEW] LOGIC ƒê·ªäNH NGHƒ®A SEGMENT ===
        segment_definitions = {
            2: """**Segment 2: "Kh√°ch h√†ng Ng√¥i sao" (Active High Value)**
            - Ch√¢n dung: Kh√°ch h√†ng l√Ω t∆∞·ªüng, chi ti√™u cao, m·ªõi t∆∞∆°ng t√°c. ƒêang 'nu√¥i s·ªëng' doanh nghi·ªáp.
            - Chi·∫øn l∆∞·ª£c: ChƒÉm s√≥c ƒë·∫∑c bi·ªát, upsell, g·ª≠i m√£ gi·∫£m gi√° khuy·∫øn kh√≠ch mua ti·∫øp. ƒê·ª´ng ƒë·ªÉ h·ªç ngu·ªôi l·∫°nh.""",
            
            1: """**Segment 1: "VIP Ng·ªß ƒë√¥ng" (At-Risk VIP)**
            - Ch√¢n dung: T·ª´ng chi r·∫•t nhi·ªÅu ti·ªÅn cho m√≥n gi√° tr·ªã l·ªõn nh∆∞ng ƒëang c√≥ d·∫•u hi·ªáu r·ªùi b·ªè (Churn).
            - Chi·∫øn l∆∞·ª£c: C·∫ßn chi·∫øn d·ªãch 'Win-back' kh·∫©n c·∫•p. G·ª≠i email nh·∫Øc nh·ªü, ƒë·ªÅ xu·∫•t ph·ª• ki·ªán ƒëi k√®m m√≥n ƒë√£ mua.""",
            
            0: """**Segment 0: "Kh√°ch h√†ng M·ªõi / Ti·ªÅm nƒÉng" (New & Active Low Value)**
            - Ch√¢n dung: Kh√°ch m·ªõi ho·∫∑c hay sƒÉn sale, Recency t·ªët nh∆∞ng ch∆∞a d√°m chi l·ªõn.
            - Chi·∫øn l∆∞·ª£c: D·ªÖ chuy·ªÉn ƒë·ªïi nh·∫•t. H√£y Cross-sell s·∫£n ph·∫©m gi√° tr·ªã cao h∆°n ho·∫∑c b√°n theo Combo.""",
            
            3: """**Segment 3: "Kh√°ch h√†ng Ph·ªï th√¥ng ƒëang tr√¥i ƒëi" (Drifting)**
            - Ch√¢n dung: Mua ƒë·ªì gi√° tr·ªã nh·ªè, ƒë√£ b·∫Øt ƒë·∫ßu qu√™n l√£ng th∆∞∆°ng hi·ªáu. S·ªë l∆∞·ª£ng ƒë√¥ng.
            - Chi·∫øn l∆∞·ª£c: Gi·ªØ li√™n l·∫°c duy tr√¨ (newsletter), kh√¥ng t·ªën qu√° nhi·ªÅu ng√¢n s√°ch marketing.""",
            
            4: """**Segment 4: "Kh√°ch h√†ng ƒê√£ m·∫•t / K√©m hi·ªáu qu·∫£" (Lost / Low Value)**
            - Ch√¢n dung: Mua m√≥n r·∫ª ti·ªÅn t·ª´ r·∫•t l√¢u, kh√¥ng quay l·∫°i.
            - Chi·∫øn l∆∞·ª£c: Kh√¥ng n√™n t·ªën chi ph√≠ qu·∫£ng c√°o (ROI th·∫•p)."""
        }
        
        # L·∫•y ƒë·ªãnh nghƒ©a cho kh√°ch h√†ng hi·ªán t·∫°i (M·∫∑c ƒë·ªãnh l√† Segment 3 n·∫øu kh√¥ng t√¨m th·∫•y)
        current_segment_info = segment_definitions.get(segment_id, segment_definitions[3])

        # 3. L·∫•y L·ªãch s·ª≠ t∆∞∆°ng t√°c
        history_log = ""
        try:
            timeline_data = self.customer_id.get_interaction_timeline_data(self.customer_id.id)
            timeline_list = timeline_data.get('timeline', [])
            if timeline_list:
                recent_events = timeline_list[:10] 
                log_lines = []
                for event in recent_events:
                    desc = event['description']
                    if len(desc) > 100: desc = desc[:100] + "..."     
                    line = f"- {event['date']} [{event['channel']}]: {event['title']} - {desc}"
                    log_lines.append(line)
                history_log = "\n".join(log_lines)
            else:
                history_log = "Ch∆∞a c√≥ l·ªãch s·ª≠ t∆∞∆°ng t√°c n√†o."
        except Exception:
            history_log = "Kh√¥ng th·ªÉ truy xu·∫•t l·ªãch s·ª≠ t∆∞∆°ng t√°c."

        # --- B∆Ø·ªöC 2.2: X·ª¨ L√ù TEXT SHAP ---
        top_n = 7
        features_description = ""
        count = 0
        for name, shap_val, feature_val in feature_impacts[:top_n]:
            if count >= top_n: break
            if name.startswith('bert_') or name.startswith('tfidf_'): continue
            direction = "tƒÉng" if shap_val > 0 else "gi·∫£m"
            features_description += f"- {name} = {feature_val:.2f}: l√†m {direction} nguy c∆° churn (ƒë·ªô m·∫°nh: {shap_val:.4f})\n"
            count += 1

        prediction_summary = "R·ªúI B·ªé (Churn)" if self.prediction_result == 'churn' else "·ªû L·∫†I (No Churn)"

        # --- B∆Ø·ªöC 3: X√ÇY D·ª∞NG PROMPT (ƒê√É T·ªêI ∆ØU H√ìA SEGMENT) ---
        prompt = f"""
        **Vai tr√≤:** B·∫°n l√† chuy√™n gia t∆∞ v·∫•n chi·∫øn l∆∞·ª£c kh√°ch h√†ng (Customer Strategy Consultant). H√£y ph√¢n t√≠ch v√† ƒë∆∞a ra gi·∫£i ph√°p h√†nh ƒë·ªông c·ª• th·ªÉ b·∫±ng ti·∫øng Vi·ªát (Markdown).

        **1. H·ªì s∆° Kh√°ch h√†ng & Ph√¢n kh√∫c (Quan tr·ªçng):**
        - **Ng√†nh h√†ng quan t√¢m:** {customer_category}
        - **Ph√¢n lo·∫°i Ph√¢n kh√∫c (Segment):** 
        {current_segment_info}
        
        - **Ch·ªâ s·ªë Chu k·ª≥ mua s·∫Øm (Gap Analysis):**
          + C√° nh√¢n kh√°ch n√†y: {personal_gap:.2f} ng√†y/l·∫ßn
          + Trung b√¨nh ng√†nh h√†ng: {category_gap:.2f} ng√†y/l·∫ßn
          (G·ª£i √Ω: N·∫øu C√° nh√¢n > Ng√†nh h√†ng nghƒ©a l√† kh√°ch mua ch·∫≠m h∆°n th·ªã tr∆∞·ªùng -> R·ªßi ro).

        **2. D√≤ng th·ªùi gian t∆∞∆°ng t√°c (G·∫ßn nh·∫•t tr∆∞·ªõc):**
        {history_log}

        **3. K·∫øt qu·∫£ D·ª± b√°o AI:**
        - **D·ª± ƒëo√°n:** {prediction_summary}
        - **X√°c su·∫•t Churn:** {self.probability:.2f}%
        
        **4. D·ªØ li·ªáu SHAP (C√°c y·∫øu t·ªë ·∫£nh h∆∞·ªüng k·ªπ thu·∫≠t):**
        {features_description}

        ---
        **Y√™u c·∫ßu ƒë·∫ßu ra (Output Format):**
        
        **T·ªïng quan:** [ƒê√°nh gi√° ng·∫Øn g·ªçn t√¨nh tr·∫°ng kh√°ch h√†ng d·ª±a tr√™n Ph√¢n kh√∫c v√† X√°c su·∫•t Churn].

        **üî¥ V·∫•n ƒë·ªÅ & R·ªßi ro:**
        - **[T√™n v·∫•n ƒë·ªÅ]:** [Gi·∫£i th√≠ch d·ª±a tr√™n Gap Analysis v√† SHAP].
        
        **üü¢ ƒêi·ªÉm s√°ng:**
        - **[T√™n ƒëi·ªÉm t·ªët]:** [Gi·∫£i th√≠ch].

        **üöÄ Chi·∫øn l∆∞·ª£c H√†nh ƒë·ªông (D·ª±a tr√™n Segment {segment_id}):**
        - **[H√†nh ƒë·ªông 1 - C·ª• th·ªÉ]:** [D·ª±a tr√™n ph·∫ßn 'Chi·∫øn l∆∞·ª£c' c·ªßa Segment {segment_id} ·ªü tr√™n, h√£y c·ª• th·ªÉ h√≥a n√≥ cho ng√†nh h√†ng {customer_category}. V√≠ d·ª•: N·∫øu l√† VIP Ng·ªß ƒë√¥ng ng√†nh Furniture, h√£y g·ª£i √Ω g·ª≠i catalog n·ªôi th·∫•t m·ªõi].
        - **[H√†nh ƒë·ªông 2 - T∆∞∆°ng t√°c]:** [D·ª±a tr√™n l·ªãch s·ª≠ t∆∞∆°ng t√°c g·∫ßn nh·∫•t].

        **L∆∞u √Ω:** H√£y b√°m s√°t ƒë·ªãnh nghƒ©a c·ªßa Segment {segment_id} ƒë·ªÉ ƒë∆∞a ra l·ªùi khuy√™n. ƒê·ª´ng ƒë∆∞a ra l·ªùi khuy√™n chung chung.
        """
        
        # --- B∆Ø·ªöC 4: G·ªåI API (NO SSL) ---
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}' # OpenAI d√πng Bearer Token Authentication
        }
        
        payload = {
            "model": "gpt-4o-mini", # Ho·∫∑c "gpt-3.5-turbo", "gpt-4o". gpt-4o-mini r·∫ª v√† nhanh.
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            "temperature": 0.7,
            "max_tokens": 2048
        }
        
        try:
            response = requests.post(
                api_endpoint, 
                headers=headers, 
                json=payload,
                timeout=60 # TƒÉng timeout cho c√°c model l·ªõn
            )
            response.raise_for_status() # T·ª± ƒë·ªông b√°o l·ªói n·∫øu status code l√† 4xx ho·∫∑c 5xx
            
            response_data = response.json()
            
            # <<< THAY ƒê·ªîI: C√°ch l·∫•y n·ªôi dung tr·∫£ v·ªÅ t·ª´ OpenAI >>>
            if 'choices' in response_data and response_data['choices']:
                raw_explanation_md = response_data['choices'][0]['message']['content']
                finish_reason = response_data['choices'][0].get('finish_reason')
                
                html_explanation = markdown2.markdown(raw_explanation_md)
                
                if finish_reason == 'length':
                    html_explanation += "<p><em>(K·∫øt qu·∫£ b·ªã c·∫Øt ng·∫Øn do gi·ªõi h·∫°n ƒë·ªô d√†i token.)</em></p>"

                self.write({'shap_ai_explanation': html_explanation})
                _logger.info(">>> ƒê√£ l∆∞u k·∫øt qu·∫£ XAI t·ª´ OpenAI th√†nh c√¥ng.")
            else:
                # Ghi log response l·ªói ƒë·ªÉ debug
                _logger.error("Ph·∫£n h·ªìi t·ª´ OpenAI kh√¥ng h·ª£p l·ªá: %s", response_data)
                raise UserError(_("AI returned an invalid response structure."))

        except requests.exceptions.HTTPError as e:
            # Ghi log chi ti·∫øt h∆°n v·ªÅ l·ªói HTTP
            _logger.error("L·ªói HTTP khi g·ªçi OpenAI API: %s - Response: %s", e, e.response.text)
            raise UserError(_("Error calling OpenAI API: %s", e.response.text))
        except Exception as e:
            _logger.error("L·ªói h·ªá th·ªëng khi g·ªçi OpenAI: %s", e)
            raise UserError(_("System Error: %s", str(e)))

        return True

    def action_view_shap_logs(self):
        """
        H√†m in log ƒë√£ ƒë∆∞·ª£c n√¢ng c·∫•p ƒë·ªÉ LO·∫†I B·ªé c√°c feature 'bert_'
        """
        self.ensure_one()
        _logger.info(">>> B·∫Øt ƒë·∫ßu in log SHAP cho Prediction ID: %d", self.id)

        if not self.shap_data_json:
            raise UserError(_("Kh√¥ng c√≥ d·ªØ li·ªáu SHAP ƒë·ªÉ ph√¢n t√≠ch."))

        try:
            shap_data = json.loads(self.shap_data_json)
        except json.JSONDecodeError:
            raise UserError(_("D·ªØ li·ªáu SHAP b·ªã l·ªói JSON."))

        # 1. S·∫Øp x·∫øp d·ªØ li·ªáu
        feature_impacts = sorted(
            zip(shap_data['feature_names'], shap_data['shap_values'], shap_data['feature_values']),
            key=lambda x: abs(x[1]),
            reverse=True
        )

        # ==============================================================================
        # IN B·∫¢NG LOG (ƒê√É L·ªåC BERT)
        # ==============================================================================
        debug_msg = ["\n" + "‚ñí" * 90]
        debug_msg.append(f" üïµÔ∏è [MANUAL CHECK] B·∫¢NG PH√ÇN T√çCH SHAP LOGS (NO BERT)")
        debug_msg.append(f" Customer: {self.customer_name} | Probability: {self.probability:.2f}%")
        debug_msg.append("‚ñí" * 90)
        debug_msg.append(f"{'RANK':<5} | {'FEATURE NAME':<45} | {'VALUE':<12} | {'IMPACT':<10} | {'EFFECT'}")
        debug_msg.append("-" * 90)

        # Bi·∫øn ƒë·∫øm th·ª© h·∫°ng hi·ªÉn th·ªã (v√¨ i s·∫Ω b·ªã nh·∫£y c√≥c khi skip bert)
        display_rank = 1

        for name, shap_val, feature_val in feature_impacts:
            # === ƒêO·∫†N QUAN TR·ªåNG: L·ªåC B·ªé BERT ===
            if name.startswith('bert_') or name.startswith('tfidf_'): 
                continue 
            # ====================================

            direction = "TƒÇNG üî¥" if shap_val > 0 else "GI·∫¢M üü¢"
            
            # C·∫Øt ng·∫Øn t√™n n·∫øu qu√° d√†i ƒë·ªÉ b·∫£ng ƒë·∫πp h∆°n
            display_name = (name[:42] + '..') if len(name) > 42 else name
            
            line = f"#{display_rank:02d}   | {display_name:<45} | {feature_val:>10.2f}   | {shap_val:>10.4f}   | {direction}"
            debug_msg.append(line)
            display_rank += 1
            
        debug_msg.append("=" * 90 + "\n")
        _logger.info("\n".join(debug_msg))

        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': 'Check Docker Logs',
                'message': 'ƒê√£ in b·∫£ng ph√¢n t√≠ch (ƒë√£ l·ªçc b·ªè Bert) ra terminal.',
                'type': 'success',
                'sticky': False,
            }
        }

    def action_send_ai_explanation_email(self):
        """
        Action g·ª≠i email ph√¢n t√≠ch AI (Phi√™n b·∫£n Render Th·ªß C√¥ng ƒë·ªÉ s·ª≠a l·ªói hi·ªÉn th·ªã).
        """
        self.ensure_one()
        import os # C·∫ßn import n√†y ƒë·ªÉ l·∫•y bi·∫øn m√¥i tr∆∞·ªùng

        # --------------------------------------------------------------------------
        # B∆Ø·ªöC a: KI·ªÇM TRA ƒêI·ªÄU KI·ªÜN (Gi·ªØ nguy√™n)
        # --------------------------------------------------------------------------
        _logger.info(">>> [Email AI] B·∫Øt ƒë·∫ßu g·ª≠i email ph√¢n t√≠ch cho KH: %s", self.customer_id.name)

        if not self.shap_ai_explanation:
            raise UserError(_("Ch∆∞a c√≥ n·ªôi dung ph√¢n t√≠ch AI. Vui l√≤ng ch·∫°y 'Explain with AI' tr∆∞·ªõc."))

        if not self.customer_id or not self.customer_id.email:
            raise UserError(_("Kh√°ch h√†ng n√†y kh√¥ng c√≥ ƒë·ªãa ch·ªâ email h·ª£p l·ªá."))

        # --------------------------------------------------------------------------
        # B∆Ø·ªöC b: X√ÅC ƒê·ªäNH TEMPLATE (Gi·ªØ nguy√™n logic)
        # --------------------------------------------------------------------------
        customer_segment = self.customer_id.x_feat_segment
        template_map = {
            0: 'ChurnPredictor.email_template_ai_segment_0',
            1: 'ChurnPredictor.email_template_ai_segment_1',
            2: 'ChurnPredictor.email_template_ai_segment_2',
            3: 'ChurnPredictor.email_template_ai_segment_3',
            4: 'ChurnPredictor.email_template_ai_segment_4',
        }
        template_xml_id = template_map.get(customer_segment)
        
        if not template_xml_id:
            raise UserError(_("Kh√¥ng t√¨m th·∫•y m·∫´u email cho segment '%s'.", customer_segment))

        try:
            template = self.env.ref(template_xml_id)
        except ValueError:
            raise UserError(_("Template '%s' kh√¥ng t·ªìn t·∫°i.", template_xml_id))
            
        # --------------------------------------------------------------------------
        # B∆Ø·ªöC c: RENDER V√Ä G·ª¨I EMAIL TH·ª¶ C√îNG (ƒê√É S·ª¨A ƒê·ªîI)
        # --------------------------------------------------------------------------
        try:
            # 1. Render Subject v√† Body
            # L√∫c n√†y body s·∫Ω ch·ª©a chu·ªói "__AI_HTML_CONTENT__" thay v√¨ l·ªói code
            rendered_subject = template._render_template(template.subject, 'churn.prediction', [self.id])[self.id]
            rendered_body = template._render_template(template.body_html, 'churn.prediction', [self.id])[self.id]

            # 2. THAY TH·∫æ PLACEHOLDER B·∫∞NG HTML TH·∫¨T
            # ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng ƒë·ªÉ HTML hi·ªÉn th·ªã ƒë·∫πp m√† kh√¥ng b·ªã l·ªói safe_eval
            if self.shap_ai_explanation:
                # ƒê·∫£m b·∫£o n·ªôi dung thay th·∫ø l√† chu·ªói (string)
                ai_html = str(self.shap_ai_explanation)
                rendered_body = rendered_body.replace('__AI_HTML_CONTENT__', ai_html)
            
            # 3. L·∫•y email ng∆∞·ªùi g·ª≠i t·ª´ Docker
            sender_email = os.environ.get('SMTP_USER')
            if not sender_email:
                sender_email = 'noreply@yourcompany.com'

            # 4. T·∫°o mail.mail
            mail_values = {
                'subject': rendered_subject,
                'body_html': rendered_body, 
                'email_to': self.customer_id.email,
                'email_from': f'"{self.env.user.name} (AI System)" <{sender_email}>',
                'author_id': self.env.user.partner_id.id,
                'state': 'outgoing',
                'auto_delete': True,
            }

            # 5. G·ª≠i
            mail = self.env['mail.mail'].sudo().create(mail_values)
            mail.send(raise_exception=False)
            
            _logger.info("ƒê√£ g·ª≠i email AI (Template: %s) t·ªõi %s", template_xml_id, self.customer_id.email)

        except Exception as e:
            _logger.error("L·ªói g·ª≠i mail: %s", e)
            raise UserError(_("L·ªói h·ªá th·ªëng khi g·ª≠i mail: %s", e))

        # --------------------------------------------------------------------------
        # B∆Ø·ªöC d: GHI LOG CHATTER (Gi·ªØ nguy√™n)
        # --------------------------------------------------------------------------
        self.customer_id.message_post(
            body=_("Email ph√¢n t√≠ch AI ƒë√£ ƒë∆∞·ª£c g·ª≠i t·ªõi %s.", self.customer_id.email),
            subtype_xmlid='mail.mt_note'
        )

        return True
    